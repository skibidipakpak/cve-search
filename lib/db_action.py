import collections
from datetime import datetime
from lib.signalNotification import sendNotification

from pymongo import InsertOne, UpdateOne

from lib.Toolkit import isBlacklisted
from lib.DatabaseLayer import (getWatchlistCVE, 
                                getAllEntities,
                                updateWatchlistCVE,
                                getWatchlistCVEbyID,
                                getInfo,
                                setColUpdate,
                                updateWatchlistCVELastmodified)
class DatabaseAction(object):

    actions = collections.namedtuple("Actions", "InsertOne UpdateOne")(0, 1)

    def __init__(self, action, collection, doc, update_watchlist=False, signal_groups=[]):

        self.action = action
        self.collection = collection
        self.doc = doc
        self.update_watchlist = update_watchlist
        self.signal_groups = signal_groups

        if self.update_watchlist and collection == 'cves':
            setColUpdate('watchlist', datetime.now())
            self._update_watchlist()


    @property
    def entry(self):
        if self.action == self.actions.InsertOne:
            return InsertOne(self.doc)
        elif self.action == self.actions.UpdateOne:
            return UpdateOne({"id": self.doc["id"]}, {"$set": self.doc}, upsert=True,)

    def _update_watchlist(self):
        if isBlacklisted(self.doc):
            return
        infos = getInfo('watchlist')
        cve = dict(self.doc)
        
        done = False
        for entity in getAllEntities():
            found = False
            for cpe in entity['cpes']:
                if found:
                    break
                for vc in cve['vulnerable_configuration']:
                    if cpe in vc: 
                        #cve is impacting an entity cpe
                        done = True
                        found = True
                        wcve = getWatchlistCVE(cve['id'], entity['name'], cpe)
                        if wcve and wcve['cvss3'] == cve['cvss3']:
                            updateWatchlistCVELastmodified({'id':wcve['id'], 'entity': entity['name'], 'product':cpe}, cve['last-modified'])
                            break
                        cve['entity'] = entity['name']
                        cve['product'] = cpe
                        cve['treated'] = False
                        if infos is None or cve['cvss3'] is None or (cve['cvss3'] and cve['cvss3'] >= float(infos['w_threshold_entity'])):
                            updateWatchlistCVE(cve)
                        if infos is None or cve['cvss3'] is None or (cve['cvss3'] and cve['cvss3'] >= float(infos['threshold_entity'])):
                            sendNotification(cve, new=True if wcve is None else False, signal_groups=self.signal_groups)
                        

        if done:
            return
        #cve is not impacting an entity
        wcve = getWatchlistCVEbyID(cve['id'])
        if wcve and wcve['cvss3'] == cve['cvss3']:
            updateWatchlistCVELastmodified({'id':wcve['id']}, cve['last-modified'])
            return
        cve['entity'] = 'all'
        cve['product'] = cve['vulnerable_configuration'][0] if cve['vulnerable_configuration'] else 'unknown' 
        cve['treated'] = False
        if infos is None or cve['cvss3'] is None or (cve['cvss3'] and cve['cvss3'] >= float(infos['w_threshold_critical'])):
            updateWatchlistCVE(cve)
        if infos is None or (cve['cvss3'] and cve['cvss3'] >= float(infos['threshold_critical'])):
            sendNotification(cve, new=True if wcve is None else False, signal_groups=self.signal_groups)
